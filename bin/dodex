#!/usr/bin/env bash

# ## Parsing Arguments
#
#   1. `-w`: working directory, with `.touched` file containing a list of all
#   touched files and a `ghpages` subfolder storing generated documents.
#   2. `-s`: sources directory, containing sources from `master` branch.

while [ $# -gt 0 ]
do
  case $1 in
  -w)    working_dir=$2
	 shift
	 ;;
  -s)    sources_dir=$2
	 shift
	 ;;
  esac

  shift
done

# ## Find Dirty Directories
#
# First, we sort out dirty directories, into `.touched_folders`

cd $working_dir
cat .touched | while read file; do dirname $file; done | sort -u > .touched_folders_with_duplications
cat .touched_folders_with_duplications | while read folder; do dirname $folder; done | sort -u > .tmp_folders_1
while [ $(cat .tmp_folders_1 | wc -l) -ne 0 ] && [ "$(cat .tmp_folders_1)" != "." ]; do
  cat .tmp_folders_1 >> .touched_folders_with_duplications
  mv .tmp_folders_1 .tmp_folders_2
  cat .tmp_folders_2 | while read folder; do dirname $folder; done | sort -u > .tmp_folders_1
done
cat .touched_folders_with_duplications | sort -u > .touched_folders

# For each dirty directories, mirror the folder structore in the `.docas/tree`
# directorie, and generate a `docas.index` there. E.g.,
#
# * .docas
#   * tree
#     * docas.index
#     * dir1
#       * docas.index
#     * dir2
#       * docas.index
#
# Each `docas.index` contains following information:
#
#   1. Type: `d` for folders, `-` for files.
#   2. Size (in bytes).
#   3. Modified date (using git log).
#   4. Last Author (using git log).
#   5. Name (file name or folder name).

cd "$sources_dir"

cat "$working_dir/.touched_folders" | while read folder; do

  echo FOLDER $folder
  mkdir -p "$working_dir/ghpages/.docas/tree/$folder"
  
  rm -f "$working_dir/ghpages/.docas/tree/$folder/docas.index"

  cd "$sources_dir/$folder"

  find . -mindepth 1 -maxdepth 1 | while read file; do

    file=$(echo $file | cut -c 3-)

    if [ "$file" != ".git" ]; then

      base="${file%.[^.]*}"
      ext="${filename:${#base} + 1}"
      if [[ -z "$base" && -n "$ext" ]]; then
	base=".$ext"
      fi

      if [ -f "$working_dir/ghpages/$folder/$base.html" ]; then
	
	echo "exists"
	documentable="1 $(LANG=C grep -cv "^\s*$" "$file")"
      
      else
	
	documentable="0 -"
      
      fi

      echo $(ls -dl "$file" | awk '{{$1 = substr($1, 0, 1)} print $1" "$5}')\
 $(git log -1 --format="\"%aD\" \"%an\"" -- "$file")\
 "\"$file\"" "$documentable" >> "$working_dir/ghpages/.docas/tree/$folder/docas.index"

    fi

  done

done

# ## Post Processing
#
# Miscellaneous patches including:
# 
#   + Submodules
#   + To be defined

cp "$sources_dir/.gitmodules" "$working_dir/ghpages/.docas/.gitmodules"
#  cd "$sources_dir"
#  git submodule init
#  git submodule | while read line; do
#  
#    submodule=$(echo $line | awk '{{$0 = substr($0, 43)} print $0}')
#    submodule_folder=$(dirname $submodule)
#    submodule_base=$(basename $submodule) 
#  
#    cat "$working_dir/ghpages/.docas/tree/$submodule_folder/docas.index" | while read entry; do
#  
#      if ! [ -z "$(echo $entry | grep "\"$submodule_base\"")" ]; then
#  
#        echo -n "s"
#        echo -n $entry | cut -c 2- | tr -d "\n"
#        cd "$sources_dir/$submodule"
#        addr="$(git remote -v | egrep -m 1 "origin")"
#        echo "addr" $addr
#        repo="$(echo $addr | grep -P "(?<=\:).*(?= )" -o)"
#        echo " \"$repo\""
#  
#      else
#  
#        echo $entry
#  
#      fi
#    
#    done # > "$working_dir/.temp_submodule.index"
#   
#    mv "$working_dir/.temp_submodule.index" "$working_dir/ghpages/.docas/tree/$submodule_folder/docas.index"
#  
#  done
