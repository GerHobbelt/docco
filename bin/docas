#!/usr/bin/env bash

### Introducing Docas.io
#
# For most developers expecting an elegant and natural approach documenting
# their source code, [Docas.io] is simplier than this stand-alone version.
# Real-time synced documentation in just 2 steps:
#
#   1. Add **[docas]** as your collaborator.
#   2. Add service hook **[http://docas.io](http://docas.io)**.
#
# Docas.io syncs the documents on GitHub pages in real time when you push
# sources to GitHub.
#
### Back to the Topic
#
# **Docas** is a command-line program which streamlines GitHub repository
# documentation task. It relies on:
#
#   - **[Docco]**, a quick and dirty, hundred-line-long, literate-programming
#   style documentation generator invented by [Jeremy Ashkenas].
#
#   - **[Docci]**, renders an `index.html` for git repository, including: recent
#   commits log, stats of languages and [slocs], and a file browser for
#   documentations. *(Not a stand-alone command yet.)*
#
#   - **[Linguist]**, the language savant behind GitHub, inspecting over 150
#   languages.
#
# **Docas** can be executed as a stand-alone command from the developer's machine,
# which will:
#
#   1. Clone the GitHub repository into a temporary directory.
#   2. Create gh-pages branch (optional) and list dirty directories.
#   3. Generate the cover page using docci.
#   4. Documente sources for each directory using docco.
#   5. Push to the remote gh-pages branch.
#
# **However**, it's recommended to further simplify the task for your every
# commit using **[docas.io]**, a service keeps your documentation in sync with
# source code automatically.
#
# [Docas]: http://docas.github.com
# [Docco]: http://jashkenas.github.com/docco
# [Jeremy Ashkenas]: http://jashkenas.github.com
# [Docci]: http://baoshan.github.com/docas/src/docci.html
# [SLOCs]: http://en.wikipedia.org/wiki/Source_lines_of_code "Source lines of code"
# [Linguist]: https://github.com/github/linguist
# [docas.io]: http://docas.io
#
### Command-line usage:
# 
# Document a repository under your own user name:
#
#     docas repository
#
# Document a repository under another user (or organization) name which you have
# write permission:
#
#     docas username/repository


### Scripting Procedure

#### Phase 0: Preparations

#   1. Stop execution when encountering any error,
#   2. Ensure enough arguments are given,
#   3. Parse arguments into user and repo variable,
#   4. Prepare a temporary working directory (don't forget to remove on exit,
#   interruption, or termination).
set -e
if [ $# -ne 1 ]; then
  echo -e "
Usage:\033[36m docas <repository>\033[0m            (repo under local configured github user name)
   or:\033[36m docas <username>/<repository>\033[0m (repo under another user or organization name, write permission required)
"
  exit
fi
if [[ $1 == */* ]]; then
  user=$(echo $1 | cut -d'/' -f1)
  repo=$(echo $1 | cut -d'/' -f2)
else
  user=$(git config github.user)
  repo=$1
fi
tempdir=$(mktemp -d /tmp/repo.$$.XXXXXXXXXX)
trap "rm -rf $tempdir; exit" 0 SIGINT SIGTERM

#### Phase 1: Clone the Repository

# (Shallow) clone the GitHub repository to `master` directory. Keep the current
# commit hash of the `master` branch, which will be included in the commit subject
# line of the `gh-pages` branch to indicate a successful synchronization.
echo "Cloning git@github.com:$user/$repo.git..."
git clone -q --depth=1 git@github.com:$user/$repo.git "$tempdir/master"
commit=$(git --git-dir=$tempdir/master/.git  rev-parse HEAD | head -c 10)

#### Phase 2: Checkout gh-pages Branch, List Dirty Directories

# Docas will only re-generate sources in the *dirty* directories, in the
# following occasions, docas consider all directories are dirty:
#
#   1. `gh-pages` does not exist.
#   2. No sync found from the `gh-pages` commits.
#   3. `gh-pages` sync found, but could not found according `master` commit.
#
# Situation 2 can be caused by first synchronization, or shallow clone; while
# situation 3 can only be caused by shallow clone.
all_directories_are_dirty () {
  git --git-dir=$tempdir/master/.git ls-tree -r --name-only HEAD \
    | while read file; do echo $(dirname $file); done \
    | sort | uniq > $tempdir/dirty_directories
  return
}

# If `gh-pages` branch does not exist, create the `gh-pages` branch following
# [GitHub instruction]:
#
#   1. Duplicate `master` directory to `gh-pages` directory.
#   2. Change to `gh-pages` directory.
#   3. Create `gh-pages` branch. 
#   4. Clear git index.
#   5. Remove all files.
#
# In this situation, docas considers all directories are dirty.
# [GitHub instruction]: http://help.github.com/pages/#project_pages_manually 
if [ $(git branch -a | grep origin\/gh-pages | wc -l) = 0 ]; then

  echo "Creating gh-pages branch..."
  cp -R $tempdir/master $tempdir/gh-pages
  cd $tempdir/gh-pages
  git symbolic-ref HEAD refs/heads/gh-pages > /dev/null
  rm .git/index
  git clean -fdx > /dev/null
  all_directories_are_dirty

# If there exists a `gh-pages` branch, which means the branch *may* contain docas
# synchronized content. So, docas will:
#
#   1. Duplicate `master` directory to `gh-pages` directory.
#   2. Checkout `gh-pages` branch in `gh-pages` directory.
#   3. Analyze dirty directories. Sources in these directories will be
#   regenerated. Dirty directories are:
#
#      * Modified directories of the `master` branch, plus
#      * Modified directories of the `gh-pages` branch.
#      
#   All sources in the touched directories will be re-generated since the
#   *JUMP TO* links of sibling documents needs be synchronized.
else
  cp -R $tempdir/master $tempdir/gh-pages
  git --git-dir=$tempdir/gh-pages/.git --work-tree=$tempdir/gh-pages checkout -qb gh-pages origin/gh-pages
  synced_ghpages_hash=$(git --git-dir=$tempdir/gh-pages/.git log --pretty=oneline \
    | egrep -m 1 -i "docas .* [0-9a-f]{10}$" \
    | head -c 10)
  synced_master_hash=$(git --git-dir=$tempdir/gh-pages/.git log --pretty=oneline \
    | egrep -m 1 -i "docas .* [0-9a-f]{10}$" \
    | tail -c 11 \
    | head -c 10)
  synced_master_hash=$(git --git-dir=$tempdir/master/.git log --pretty=oneline \
    | egrep -m 1 "^$synced_master_hash" \
    | head -c 10 \
    | xargs echo)

  echo "$synced_master_hash | $synced_ghpages_hash"

  # If we can not securely list all touched files, then docas treat all
  # as dirty directories.
  if [ -z $synced_ghpages_hash ] || [ -z $synced_master_hash ]; then
    echo "gh-pages branch out-of sync for a long time, rebuilding..."
    all_directories_are_dirty
 
  # If we can securely list all touched files in the `master` and `gh-pages`
  # branch since last sync, output unique directories into dirty_directories file.
  else
    echo "Found docas comitted gh-pages, synced with $synced_master_hash"
    git --git-dir=$tempdir/gh-pages/.git diff --name-only $synced_ghpages_hash..HEAD \
      | while read file; do dirname $file; done >  $tempdir/dirty_directories
    git --git-dir=$tempdir/master/.git diff --name-only $synced_master_hash..HEAD \
      | while read file; do dirname $file; done >> $tempdir/dirty_directories
    sort -u $tempdir/dirty_directories -o $tempdir/dirty_directories
  fi

fi

# If no file of the `master` or the `gh-pages` branch was changed, exit the
# program with notification. Nothing needs be done further. Neither the cover
# page nor any document needs be re-generated.
if [ $(cat $tempdir/dirty_directories | wc -l) -eq 0 ]; then 
  echo "No file has been touched. Are you kidding?"
  exit
fi

#### Phase 3: Generate Cover Page (using Docci)
echo "Generating cover page..."

# Before calling the **docci** command line, following materials should be
# ready:
#
#   1. a language statistics file named `stat`, and,
#   2. a list of all recognized sources named `list`.
#
# Keep the path name of the master directory into a local variable, which will
# be used to remove the prefix from the source list.
masterdir=$tempdir/master
masterdirlength=${#masterdir}+1
cd /usr/local/lib/docas/vendor/linguist
bundle exec linguist $tempdir/master > $tempdir/stat
find $tempdir/master -type f \
  | xargs bundle exec source_only \
  | while read file; do echo ${file:$masterdirlength}; done > $tempdir/list

# Make sure a stylesheet for `index.html` exists. User modification will be
# honored. In case of the stylesheet doesn't exists, copy the default stylesheet
# to the `stylesheet` folder.
if ! [ -f $tempdir/gh-pages/stylesheets/index.css ]; then
  mkdir -p $tempdir/gh-pages/stylesheets
  cp /usr/local/lib/docas/resources/docci.css $tempdir/gh-pages/stylesheets/index.css
fi

# Invoke the **docci** command-line to generate `index.html` for `master`
# directory.
docci -c "stylesheets/index.css" -o $tempdir/gh-pages $tempdir/master

#### Phase 4: Generate Documents (using Docco)
echo "Generating documents..."

##### 1: Prepare Docco Stylesheet

# Make sure a stylesheet for documents exists. User modification will be
# honored. In case of the stylesheet doesn't exists, copy the default stylesheet
# to the `stylesheets` folder.
if ! [ -f $tempdir/gh-pages/stylesheets/docco.css ]; then
  mkdir -p $tempdir/gh-pages/stylesheets
  cp /usr/local/lib/docas/resources/docco.css $tempdir/gh-pages/stylesheets/docco.css
fi

# For each dirty directory, do:
cat $tempdir/dirty_directories | while read dir; do

  ##### 2: Clear Touched Directories

  # Remove all files generated by **docco** in the touched directories. A
  # `generator` meta tag in the docco template is used as a signagure to
  # identify docco generated documents.
  if [ -d $tempdir/gh-pages/$dir ]; then
    find $tempdir/gh-pages/$dir -maxdepth 1 -type f -print0 \
      | xargs -0 grep -liZ '<meta name="generator" content="docco.*">' \
      | xargs -0 rm -f
  fi

  ##### 3: Generate Documents

  # Process sources for each directory, so the **jump to** section will contain
  # links to sibling documents only. Since both the GitHub [project page] link
  # structure, aka `<user>.github.com/<repo>`, and CNAME version, e.g.
  # `docs.awesomeproject.com` should be supported, relative stylesheet path
  # should be used in the HTML sources.
  #
  # [Project Page]: http://help.github.com/pages/#project_pages_manually
  if [ $dir = '.' ]; then
    match="^[^/]+$"
    relative_path_to_root=""
  else
    match="^$dir/[^/]+$"
    depth=$(($(grep -o "/" <<< "$dir" | wc -l) + 1))
    relative_path_to_root=$(eval printf "../%.0s" {1..$depth})
  fi
  egrep $match $tempdir/list | while read file; do
    echo "$tempdir/master/$file"
  done | xargs docco -c "$relative_path_to_root"stylesheets/docco.css -o $tempdir/gh-pages/$dir # > /dev/null  

done

#### Phase 5: Synchronize with GitHub

# Docas will *only* touch the gh-pages branch when necessary.
#
# Use the [porcelain layer] of git-status to count files been created, modified,
# or deleted. Output these numbers to the terminal.
#
# [Porcelain Layer]:
# http://schacon.github.com/git/git.html#_high_level_commands_porcelain
status=$(git --git-dir=$tempdir/gh-pages/.git --work-tree=$tempdir/gh-pages status --porcelain)

echo "Created:$(echo "$status" | egrep "^(\?\?)" | wc -l)"
echo "Altered:$(echo "$status" | egrep "^(M| M)" | wc -l)"
echo "Deleted:$(echo "$status" | egrep "^(D| D)" | wc -l)"

# If there exists any file created, modified, or deleted, then:
# 
#   1. Synchronize git index with local files,
#   2. commit the `gh-pages` branch, and,
#   3. synchronize the `gh-pages` branch with GitHub remotely.
if [ $(echo "$status" | wc -l) -gt 0 ]; then
  echo "Synchronizing GitHub pages remotely..."
  git --git-dir=$tempdir/gh-pages/.git --work-tree=$tempdir/gh-pages add .
  git --git-dir=$tempdir/gh-pages/.git --work-tree=$tempdir/gh-pages commit -qam "Docas synced with $commit"
  git --git-dir=$tempdir/gh-pages/.git --work-tree=$tempdir/gh-pages push -qf origin gh-pages
  echo "http://$user.github.com/$repo is now up-to-date. Crowd applauds."

# Nothing to do when no file was created, modified, or deleted. The `gh-pages`
# branch is in-sync with the `master` branch already.
else
  echo "http://$user.github.com/$repo doesn't need to sync. Code harder."
fi
